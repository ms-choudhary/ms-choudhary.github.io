<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://ms-choudhary.github.io name=base><title>
            
                Interfaces in Go
            
        </title><meta content="Interfaces in Go" property=og:title><link href=https://ms-choudhary.github.io/fonts.css rel=stylesheet><link media="(prefers-color-scheme: dark)" href=/syntax-theme-dark.css rel=stylesheet><link media="(prefers-color-scheme: light)" href=/syntax-theme-light.css rel=stylesheet><link title="
    Mohit Choudhary
" href=https://ms-choudhary.github.io/atom.xml rel=alternate type=application/atom+xml><link title="
    Mohit Choudhary
" href=https://ms-choudhary.github.io/rss.xml rel=alternate type=application/rss+xml><link href=https://ms-choudhary.github.io/theme/light.css rel=stylesheet><link href=https://ms-choudhary.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://ms-choudhary.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://ms-choudhary.github.io/main.css media=screen rel=stylesheet><body><div class=left-content></div><div class=content><nav><div class=left-nav><a href=https://ms-choudhary.github.io>Mohit Choudhary</a><div class=socials><a class=social href=https://www.linkedin.com/in/mohit-choudhary-32584939/ rel=me> <img alt=linkedin src=https://ms-choudhary.github.io/icons/social/linkedin.svg> </a><a class=social href=https://github.com/ms-choudhary rel=me> <img alt=github src=https://ms-choudhary.github.io/icons/social/github.svg> </a><a class=social href=/atom.xml rel=me> <img alt=rss src=https://ms-choudhary.github.io/icons/social/rss.svg> </a></div></div><div class=right-nav><a href=https://ms-choudhary.github.io/posts style=margin-right:.5em>/posts</a><a href=https://ms-choudhary.github.io/projects style=margin-right:.5em>/projects</a><a href=https://ms-choudhary.github.io/notes style=margin-right:.5em>/notes</a><a href=https://ms-choudhary.github.io/learn style=margin-right:.5em>/learn</a><a href=https://ms-choudhary.github.io/tags style=margin-right:.5em>/tags</a><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://ms-choudhary.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://ms-choudhary.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></div></nav><div data-selector="main article p" class=visible-element-observer-root><main><article><div class=title><div class=page-header>Interfaces in Go</div><div class=meta>Posted on <time>2018-06-02</time> :: Updated on <time>2025-09-24</time><span class=tags-label>::</span><span class=tags> <a class=post-tag href=https://ms-choudhary.github.io/tags/golang/>golang</a> </span></div></div><section class=body><p>Go is a strongly typed language, which doesn't support generics. Although not your common object oriented language like java, go does support types and methods on those types. There are no constructors, inheritance. The whole idea is to intentionally keep it light weight. Interface is something similar to what you've in other languages. This is how you define them:<pre class=z-code><code><span class="z-text z-plain">package io
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">type Writer interface {
</span><span class="z-text z-plain">    Write(p []byte) (n int, err error)
</span><span class="z-text z-plain">}
</span></code></pre><p>Interfaces are contracts:<blockquote><p>There is another kind of type in Go called an interface type. An interface is an abstract type. It doesnâ€™t expose the representation or internal structure of its values, or the set of basic operations they support; it reveals only some of their methods. When you have a value of an interface type, you know nothing about what it is; you know only what it can do, or more precisely, what behaviors are provided by its methods.</blockquote><p>As is expected, if a function expects <code>io.Writer</code> as argument. We can pass any of the concrete type which implements <code>io.Writer</code> to it. And based on the actual type, same function can either write to <code>os.Stdout</code> or a file or a string buffer. Thus, exhibiting polymorphism.<p>So how do concrete types implement a particular interface. Well it need not to. Go interfaces are implicitly satisfied if a particular concrete type implements the methods of the interface (For example, if <code>os.File</code> implements a <code>Write</code> method with signature similar to above, it satisfies that interface). This way you can define a new interface and existing types will still satisfy it, if they support all methods. This is particularly usefully if you don't own those types.<h1 id=internals>Internals</h1><p>Interface internally consists of two values: dynamic type and dynamic value. Like other types, interfaces are initialized, by default, to well defined value, where both <em>type</em> and <em>value</em> are <code>nil</code>:<pre class=z-code><code><span class="z-text z-plain">var w io.Writer
</span></code></pre><p><img alt="Full-width image" src=https://i.ibb.co/Nn8jnnb/f7JtK8G.png><p>An interface is <code>nil</code> when it's <em>type</em> value is <code>nil</code>. Just like pointers & other aggregate types, interfaces can be compared to <code>nil</code> (i.e., <code>w == nil</code> or <code>w != nil</code>).<p>Interfaces can only be assigned to types which support all methods defined by the interface.<pre class=z-code><code><span class="z-text z-plain">var w io.Writer
</span><span class="z-text z-plain">// os.Stdout is *os.File pointing to standard output
</span><span class="z-text z-plain">w = os.Stdout
</span></code></pre><p>On assignment, <em>type</em> of interface value get set to the actual concrete type & <em>value</em> to it's actual value.<p><img alt src=https://i.ibb.co/drgKgbv/O8uK3cF.png><p>When we execute a method on interface,<pre class=z-code><code><span class="z-text z-plain">w.Write([]byte("hello"))
</span></code></pre><p>compiler infers the address of the method from the actual concrete type and calls it with <em>value</em> as receiver. So <code>w.Write</code> internally executes <code>(*os.File).Write</code>.<h1 id=equality>Equality</h1><p>Interface can be compared for equality using <code>==</code> & <code>!=</code>. Two interfaces are equal if both their <em>type</em> and <em>value</em> are equal.</section></article></main></div></div><div class=right-content></div>